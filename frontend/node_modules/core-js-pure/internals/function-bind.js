'use strict';
<<<<<<< HEAD
=======
var global = require('../internals/global');
>>>>>>> fe
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var isObject = require('../internals/is-object');
var hasOwn = require('../internals/has-own-property');
var arraySlice = require('../internals/array-slice');
var NATIVE_BIND = require('../internals/function-bind-native');

<<<<<<< HEAD
var $Function = Function;
=======
var Function = global.Function;
>>>>>>> fe
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
<<<<<<< HEAD
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
=======
    factories[argsLength] = Function('C,a', 'return new C(' + join(list, ',') + ')');
>>>>>>> fe
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
<<<<<<< HEAD
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
=======
module.exports = NATIVE_BIND ? Function.bind : function bind(that /* , ...args */) {
>>>>>>> fe
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};
